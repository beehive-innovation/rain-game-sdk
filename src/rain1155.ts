/* eslint-disable prettier/prettier */
import {
  Signer,
  BytesLike,
  BigNumber,
  BigNumberish,
  ContractTransaction,
  ethers,
} from 'ethers';
import {
  TxOverrides,
  ReadTxOverrides,
  RainContract,
  ERC721,
  ERC20,
  ERC1155,
} from 'rain-sdk';
import { Rain1155__factory } from './typechain';
import { AddressBook } from './addresses';
import { StateConfigStruct } from './typechain/Rain1155';
import { concat, op, Opcode, VMState, getCanMintConfig } from './utils';

/**
 * @public
 * A class for deploying and calling methods in Rain1155 contract.
 *
 *
 * @remarks
 *   This class provides an easy way to deploy and interact with Rain1155 contracts
 *
 * @example
 * ```typescript
 * import { Rain1155 } from 'rain-sdk'
 *
 * // To connect to an existing Rain1155 just pass the address and an ethers.js Signer.
 * const existing Rain1155 = new Rain1155(address, signer)
 *
 * // Once you have a Rain1155, you can call the smart contract methods:
 * ```
 *
 */

/**
 * Custom error class
 */
class ScriptError extends Error {
  constructor(msg: string) {
    super(msg);

    // Set the prototype explicitly.
    Object.setPrototypeOf(this, ScriptError.prototype);
  }

  error(type: string, attribute: string) {
    return `ScriptError: type "${type}" is missing "${attribute}".`;
  }
}

export enum Type {
  ERC20,
  ERC1155,
}

export enum Conditions {
  NONE,
  BLOCK_NUMBER,
  ERC20BALANCE,
  ERC721BALANCE,
  ERC1155BALANCE,
}

/**
 *
 * @param prices Array of type price
 * @returns VMState: StateConfig, string[]: array of token addresses.
 */
const generatePriceScript = (
  prices: price[],
  position: number
): [Uint8Array, BigNumberish[], string[]] => {
  let error = new ScriptError('Invalid Script parameters.');
  let currencies: string[] = [];
  let sources: BytesLike[] = [];
  let constants: BigNumberish[] = [];
  let i;
  if (prices.length === 0) {
    // If empty config received return source with one opcode and empty currencies arary.
    return [concat([op(Opcode.CONSTANT)]), constants, currencies];
  }
  for (i = 0; i < prices.length; i++) {
    // else loop over the prices array
    let obj = prices[i];
    if (obj.currency.type === Type.ERC1155) {
      // check price type
      sources.push(op(Opcode.CONSTANT, ++position)); // token type ERC1155 = 1
      sources.push(op(Opcode.CONSTANT, ++position)); // tokeinID
      sources.push(op(Opcode.CONSTANT, ++position)); // amount
      // pushed 3 items in constants so used ++pos 3 times, then (Opcode.CONSTANT, pos) will point to correct constant
      constants.push(obj.currency.type); // push currency type in constants
      if (obj.currency.tokenId) {
        constants.push(obj.currency.tokenId); // push tokenId in constants
      } else throw error.error('ERC1155', 'currency.tokenId');
      constants.push(obj.amount); // push amount in constants
    } else {
      // ERC20 type
      sources.push(op(Opcode.CONSTANT, ++position)); // token type ERC20 = 0
      sources.push(op(Opcode.CONSTANT, ++position)); // amount
      // pushed 2 items in constants so used ++pos 2 times, then (Opcode.CONSTANT, pos) will point to correct constant
      constants.push(obj.currency.type); // push currency type in constants
      constants.push(obj.amount); // push amount in constants
    }
    currencies.push(obj.currency.address);
  }
  return [concat(sources), constants, currencies]; // return the stateConfig and currencies[]
};

/**
 *
 * @param priceScritp StateConfig generated by generatePriceScript()
 * @param currencies array of token addresses
 * @returns array of priceConfig
 */
const generatePriceConfig = (
  priceScript: VMState,
  currencies: string[]
): price[] => {
  let prices: price[] = [];
  const source: BytesLike = ethers.utils.arrayify(priceScript.sources[1]); // Convert the bytesArray to Uint8Array
  const constants = priceScript.constants;
  let index = source[1];
  let i = 0;
  while (index < constants.length) {
    if (Number(constants[index]) === 0) {
      prices.push({
        currency: {
          type: Number(constants[index]),
          address: currencies[i++],
        },
        amount: BigNumber.from(constants[index + 1]),
      });
      index = index + 2;
    } else if (Number(constants[index]) === 1) {
      prices.push({
        currency: {
          type: Number(constants[index]),
          tokenId: constants[index + 1],
          address: currencies[i++],
        },
        amount: BigNumber.from(constants[index + 2]),
      });
      index = index + 3;
    }
  }
  return prices;
};

/**
 *
 * @param conditions array of conditions
 * @returns [Uint8Array, BigNumberish[]] for canMint
 */
const generateCanMintScript = (
  conditionsGroup: condition[][]
): [Uint8Array, BigNumberish[]] => {
  let error = new ScriptError('Invalid Script parameters.');
  let pos = -1;
  let sources: Uint8Array[] = [];
  let constants: BigNumberish[] = [];
  let i;
  let outerArrIterator;
  for (
    outerArrIterator = 0;
    outerArrIterator < conditionsGroup.length;
    outerArrIterator++
  ) {
    const conditions = conditionsGroup[outerArrIterator];
    for (i = 0; i < conditions.length; i++) {
      // Loop over conditions
      let condition = conditions[i];
      if (condition.type === Conditions.NONE) {
        // No condition
        constants.push(1); // push 1 in constants, will return true for Every OP in the end
        sources.push(op(Opcode.CONSTANT, ++pos));
      } else if (condition.type === Conditions.BLOCK_NUMBER) {
        if (condition.blockNumber) {
          constants.push(condition.blockNumber);
        } else throw error.error('BLOCK_NUMBER', 'blockNumber');
        sources.push(op(Opcode.BLOCK_NUMBER));
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.GREATER_THAN));
      } else if (condition.type === Conditions.ERC20BALANCE) {
        if (condition.address) {
          constants.push(condition.address);
        } else throw error.error('ERC20BALANCE', 'address');
        if (condition.balance) {
          constants.push(condition.balance);
        } else throw error.error('ERC20BALANCE', 'balance');
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.CONTEXT, 0));
        sources.push(op(Opcode.IERC20_BALANCE_OF));
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.GREATER_THAN));
      } else if (condition.type === Conditions.ERC721BALANCE) {
        if (condition.address) {
          constants.push(condition.address);
        } else throw error.error('ERC721BALANCE', 'address');
        if (condition.balance) {
          constants.push(condition.balance);
        } else throw error.error('ERC721BALANCE', 'balance');
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.CONTEXT, 0));
        sources.push(op(Opcode.IERC721_BALANCE_OF));
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.GREATER_THAN));
      } else if (condition.type === Conditions.ERC1155BALANCE) {
        if (condition.address) {
          constants.push(condition.address);
        } else throw error.error('ERC1155BALANCE', 'address');
        if (condition.id) {
          constants.push(condition.id);
        } else throw error.error('ERC1155BALANCE', 'id');
        if (condition.balance) {
          constants.push(condition.balance);
        } else throw error.error('ERC1155BALANCE', 'balance');
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.CONTEXT));
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.IERC1155_BALANCE_OF));
        sources.push(op(Opcode.CONSTANT, ++pos));
        sources.push(op(Opcode.GREATER_THAN));
      }
    }
    sources.push(op(Opcode.EVERY, conditions.length)); // EVERY opcode to check  all conditions within this group are true
  }
  sources.push(op(Opcode.ANY, conditionsGroup.length)); // Last OP as ANY to check any of the above condition group is true
  return [concat(sources), constants];
};

/**
 *
 * @param canMintScript StateConfig generated by generateCanMintScript
 * @returns array of conditions
 */
const generateCanMintConfig = (canMintScript: VMState): condition[][] => {
  let conditions: condition[][] = [];
  let sources = ethers.utils.arrayify(canMintScript.sources[0]); // Convert from BytesArray to Uint8Array
  let constants = canMintScript.constants;
  let opcodes: number[][] = [[]];
  let opcodeCounter = 0;
  for (let i = 0; i < sources.length - 2; i++) {
    // convert Uint8Array to number[]
    let op = parseInt(sources[i].toString());
    if (!(i % 2)) {
      if (op == Opcode.EVERY) {
        // If EVERY opcode found, split the current opcode array and increment the index of sources by 1
        conditions.push(getCanMintConfig(opcodes[opcodeCounter], constants));
        opcodes[++opcodeCounter] = [];
        i++;
        continue;
      }
    }
    // If a normal opcode, then push it directly.
    opcodes[opcodeCounter].push(op);
  }
  return conditions;
};

const generateScript = (
  conditionsGroup: condition[][],
  prices: price[]
): [VMState, string[]] => {
  const [canMintSource, canMintConstants] =
    generateCanMintScript(conditionsGroup);

  const [priceSources, priceConstants, currencies] = generatePriceScript(
    prices,
    canMintConstants.length - 1
  );

  const sources = [canMintSource, priceSources];
  const constants = [...canMintConstants, ...priceConstants];

  return [
    {
      sources: sources,
      constants: constants,
    },
    currencies,
  ];
};

const generateConfig = (
  script: VMState,
  currencies: string[]
): [condition[][], price[]] => {
  const canMintConfig = generateCanMintConfig(script);
  const priceConfig = generatePriceConfig(script, currencies);
  return [canMintConfig, priceConfig];
};
export class Rain1155 extends RainContract {
  protected static readonly nameBookReference = 'Rain1155';

  /**
   * Constructs a new Rain1155 from a known address.
   *
   * @param address - The address of the Rain1155 contract
   * @param signer - An ethers.js Signer
   * @returns A new Rain1155 instance
   *
   */
  constructor(address: string, signer: Signer) {
    super(address, signer);
    const _rain1155 = Rain1155__factory.connect(address, signer);

    this.assets = _rain1155.assets;
    this.balanceOf = _rain1155.balanceOf;
    this.balanceOfBatch = _rain1155.balanceOfBatch;
    this.canMint = _rain1155.canMint;
    this.createNewAsset = _rain1155.createNewAsset;
    this.getAssetPrice = _rain1155.getAssetPrice;
    this.isApprovedForAll = _rain1155.isApprovedForAll;
    this.mintAssets = _rain1155.mintAssets;
    this.safeBatchTransferFrom = _rain1155.safeBatchTransferFrom;
    this.safeTransferFrom = _rain1155.safeTransferFrom;
    this.setApprovalForAll = _rain1155.setApprovalForAll;
    this.supportsInterface = _rain1155.supportsInterface;
    this.totalAssets = _rain1155.totalAssets;
    this.uri = _rain1155.uri;
  }

  public readonly connect = (signer: Signer): Rain1155 => {
    return new Rain1155(this.address, signer);
  };

  public static getBookAddress(chainId: number): string {
    return AddressBook.getAddressesForChainId(chainId)[this.nameBookReference];
  }

  public static readonly subgraph =
    'https://api.thegraph.com/subgraphs/name/vishalkale151071/blocks';

  public static readonly generateScript = generateScript;
  public static readonly generateConfig = generateConfig;

  public readonly getPrice = async (
    _assetId: BigNumberish,
    _paymentToken: string,
    _units: BigNumberish
  ): Promise<price> => {
    let stack = await this.getAssetPrice(_assetId, _paymentToken, _units);
    if (stack[0].eq(BigNumber.from(Type.ERC20))) {
      return {
        currency: {
          type: Type.ERC20,
          address: _paymentToken,
        },
        amount: stack[1],
      };
    }
    return {
      currency: {
        type: Type.ERC1155,
        address: _paymentToken,
        tokenId: stack[1],
      },
      amount: stack[2],
    };
  };

  public readonly checkAllowance = async (
    assetId: BigNumberish,
    prices: price[],
    units: BigNumberish,
    rain1155Address: string,
    signer: string
  ): Promise<allowance[]> => {
    let allowances: allowance[] = [];
    for (let i = 0; i < prices.length; i++) {
      let price = prices[i];
      if (price.currency.type === Type.ERC20) {
        let ERC20Contract = new ERC20(price.currency.address, this.signer);
        let amount = (
          await this.getPrice(assetId, price.currency.address, units)
        ).amount;
        let allowed = await ERC20Contract.allowance(signer, rain1155Address);
        allowances.push({
          type: Type.ERC20,
          address: price.currency.address,
          allowed: allowed >= amount ? true : false,
          amount: allowed >= amount ? BigNumber.from(0) : amount.sub(allowed),
          name: await ERC20Contract.name(),
          symbol: await ERC20Contract.name(),
        });
      } else {
        let ERC1155Contract = new ERC1155(price.currency.address, this.signer);
        let erc1155Price = await this.getPrice(
          assetId,
          price.currency.address,
          units
        );
        let allowed = await ERC1155Contract.isApprovedForAll(
          signer,
          rain1155Address
        );
        let tokenURI: string;
        try {
          tokenURI = erc1155Price.currency.tokenId
            ? await ERC1155Contract.uri(erc1155Price.currency.tokenId)
            : '';
        } catch (error) {
          tokenURI = `TokenID ${erc1155Price.currency.tokenId} may not exist now`;
        }
        allowances.push({
          type: Type.ERC1155,
          address: price.currency.address,
          allowed: allowed,
          amount: allowed ? BigNumber.from(0) : erc1155Price.amount,
          tokenId: erc1155Price.currency.tokenId,
          tokenURI: tokenURI,
        });
      }
    }

    return allowances;
  };

  public readonly assets: (
    arg0: BigNumberish,
    overrides?: ReadTxOverrides
  ) => Promise<AssetDetails>;

  public readonly balanceOf: (
    account: string,
    id: BigNumberish,
    overrides?: ReadTxOverrides
  ) => Promise<BigNumber>;

  public readonly balanceOfBatch: (
    accounts: string[],
    ids: BigNumberish[],
    overrides?: ReadTxOverrides
  ) => Promise<BigNumber[]>;

  public readonly canMint: (
    _assetId: BigNumberish,
    _account: string,
    overrides?: ReadTxOverrides
  ) => Promise<boolean>;

  public readonly createNewAsset: (
    _config: AssetConfig,
    overrides?: TxOverrides
  ) => Promise<ContractTransaction>;

  public readonly getAssetPrice: (
    _assetId: BigNumberish,
    _paymentToken: string,
    _units: BigNumberish,
    overrides?: ReadTxOverrides
  ) => Promise<BigNumber[]>;

  public readonly isApprovedForAll: (
    account: string,
    operator: string,
    overrides?: ReadTxOverrides
  ) => Promise<boolean>;

  public readonly mintAssets: (
    _assetId: BigNumberish,
    _units: BigNumberish,
    overrides?: TxOverrides
  ) => Promise<ContractTransaction>;

  public readonly safeBatchTransferFrom: (
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: TxOverrides
  ) => Promise<ContractTransaction>;

  public readonly safeTransferFrom: (
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: TxOverrides
  ) => Promise<ContractTransaction>;

  public readonly setApprovalForAll: (
    operator: string,
    approved: boolean,
    overrides?: TxOverrides
  ) => Promise<ContractTransaction>;

  public readonly supportsInterface: (
    interfaceId: BytesLike,
    overrides?: ReadTxOverrides
  ) => Promise<boolean>;

  public readonly totalAssets: (
    overrides?: ReadTxOverrides
  ) => Promise<BigNumber>;

  public readonly uri: (
    _tokenId: BigNumberish,
    overrides?: ReadTxOverrides
  ) => Promise<string>;
}

export type AssetDetails = {
  lootBoxId: BigNumber;
  id: BigNumber;
  vmStateConfig: StateConfigStruct;
  vmStatePointer: string;
  recipient: string;
  tokenURI: string;
};

export type AssetConfig = {
  name: string;
  description: string;
  lootBoxId: BigNumber;
  vmStateConfig: StateConfigStruct;
  currencies: string[];
  recipient: string;
  tokenURI: string;
};

// TODO: Update the rain-sdk to use the correctState
export type State = {
  stackIndex: BigNumber;
  stack: BigNumber[];
  sources: string[];
  constants: BigNumber[];
  arguments: BigNumber[];
};

export type currency = {
  type: number;
  address: string;
  tokenId?: BigNumberish;
};

export type price = {
  currency: currency;
  amount: BigNumber;
};

export type condition = {
  type: number;
  blockNumber?: number;
  tierAddress?: string;
  tierCondition?: number;
  address?: string;
  balance?: BigNumber;
  id?: BigNumber;
};

export type allowance = {
  type: number;
  address: string;
  allowed: boolean;
  amount?: BigNumber;
  tokenId?: BigNumberish;
  tokenURI?: string;
  name?: string;
  symbol?: string;
};
